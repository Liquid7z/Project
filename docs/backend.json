{
  "entities": {
    "UserProfile": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserProfile",
      "type": "object",
      "description": "Represents a user profile in the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user profile.",
          "format": "uuid"
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "displayName": {
          "type": "string",
          "description": "Display name of the user."
        },
        "photoURL": {
          "type": "string",
          "description": "URL of the user's profile photo.",
          "format": "uri"
        },
        "creationTime": {
          "type": "string",
          "description": "Timestamp indicating when the user profile was created.",
          "format": "date-time"
        },
        "lastSignInTime": {
          "type": "string",
          "description": "Timestamp indicating when the user last signed in.",
          "format": "date-time"
        },
        "subscriptionId": {
          "type": "string",
          "description": "Reference to Subscription. (Relationship: UserProfile 1:1 Subscription)"
        }
      },
      "required": [
        "id",
        "email"
      ]
    },
    "Subscription": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Subscription",
      "type": "object",
      "description": "Represents a user's subscription status and details.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the subscription."
        },
        "tier": {
          "type": "string",
          "description": "Subscription tier (e.g., free, premium)."
        },
        "startDate": {
          "type": "string",
          "description": "Date the subscription started.",
          "format": "date-time"
        },
        "endDate": {
          "type": "string",
          "description": "Date the subscription expires.",
          "format": "date-time"
        },
        "isCancelled": {
          "type": "boolean",
          "description": "Indicates if the subscription has been cancelled."
        }
      },
      "required": [
        "id",
        "tier",
        "startDate",
        "endDate"
      ]
    },
    "HandwritingModel": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "HandwritingModel",
      "type": "object",
      "description": "Represents a user's handwriting style model.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the handwriting model."
        },
        "userId": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:N HandwritingModel)"
        },
        "modelDataURL": {
          "type": "string",
          "description": "URL where the handwriting style model data is stored.",
          "format": "uri"
        },
        "creationDate": {
          "type": "string",
          "description": "Date the handwriting style model was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "modelDataURL",
        "creationDate"
      ]
    },
    "GeneratedAssignment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GeneratedAssignment",
      "type": "object",
      "description": "Represents a generated assignment.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the generated assignment."
        },
        "userId": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:N GeneratedAssignment)"
        },
        "inputContent": {
          "type": "string",
          "description": "The original content used to generate the assignment."
        },
        "generatedContentURL": {
          "type": "string",
          "description": "URL where the generated assignment output is stored.",
          "format": "uri"
        },
        "creationDate": {
          "type": "string",
          "description": "Date the assignment was generated.",
          "format": "date-time"
        },
        "handwritingModelId": {
          "type": "string",
          "description": "Reference to HandwritingModel. (Relationship: HandwritingModel 1:N GeneratedAssignment)"
        }
      },
      "required": [
        "id",
        "userId",
        "inputContent",
        "generatedContentURL",
        "creationDate"
      ]
    },
    "Subject": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Subject",
      "type": "object",
      "description": "Represents a subject or category for organizing notes.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the subject."
        },
        "userId": {
          "type": "string",
          "description": "The ID of the user who owns this subject."
        },
        "title": {
          "type": "string",
          "description": "The title of the subject."
        },
        "description": {
          "type": "string",
          "description": "A brief description of the subject."
        },
        "noteCount": {
          "type": "number",
          "description": "The number of notes within this subject."
        },
        "lastEdited": {
          "type": "string",
          "description": "Timestamp of the last edit.",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "The status of the subject.",
          "enum": ["active", "archived"]
        }
      },
      "required": ["id", "userId", "title", "lastEdited", "status"]
    },
    "Note": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Note",
      "type": "object",
      "description": "Represents a single note within a subject.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the note."
        },
        "userId": {
          "type": "string",
          "description": "The ID of the user who owns this note."
        },
        "subjectId": {
          "type": "string",
          "description": "The ID of the subject this note belongs to."
        },
        "title": {
          "type": "string",
          "description": "The title of the note."
        },
        "content": {
          "type": "string",
          "description": "The HTML content of the note."
        },
        "lastEdited": {
          "type": "string",
          "description": "Timestamp of the last edit.",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "The status of the note.",
          "enum": ["active", "archived"]
        }
      },
      "required": ["id", "userId", "subjectId", "title", "lastEdited", "status"]
    }
  },
  "auth": {
    "providers": [
      "password",
      "google.com"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "Stores user profile information. Path-based ownership for user data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/subscriptions/{subscriptionId}",
        "definition": {
          "entityName": "Subscription",
          "schema": {
            "$ref": "#/backend/entities/Subscription"
          },
          "description": "Stores subscription information for each user. Path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "subscriptionId",
              "description": "The unique identifier of the subscription."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/handwritingModels/{handwritingModelId}",
        "definition": {
          "entityName": "HandwritingModel",
          "schema": {
            "$ref": "#/backend/entities/HandwritingModel"
          },
          "description": "Stores handwriting style models for each user. Path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "handwritingModelId",
              "description": "The unique identifier of the handwriting model."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/generatedAssignments/{generatedAssignmentId}",
        "definition": {
          "entityName": "GeneratedAssignment",
          "schema": {
            "$ref": "#/backend/entities/GeneratedAssignment"
          },
          "description": "Stores generated assignments for each user. Path-based ownership. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "generatedAssignmentId",
              "description": "The unique identifier of the generated assignment."
            }
          ]
        }
      },
       {
        "path": "/users/{userId}/subjects/{subjectId}",
        "definition": {
          "entityName": "Subject",
          "schema": {
            "$ref": "#/backend/entities/Subject"
          },
          "description": "Stores note subjects for each user. Path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "subjectId",
              "description": "The unique identifier for the subject."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/subjects/{subjectId}/notes/{noteId}",
        "definition": {
          "entityName": "Note",
          "schema": {
            "$ref": "#/backend/entities/Note"
          },
          "description": "Stores notes for a given subject. Path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "subjectId",
              "description": "The unique identifier for the subject."
            },
            {
              "name": "noteId",
              "description": "The unique identifier for the note."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to support the LiqAI application's user authentication, premium subscription system, handwriting analysis, content input, and AI handwriting generation features, while adhering to the principles of Authorization Independence, Clarity of Intent, DBAC, QAPs, and Invariants.\n\n*   **Authorization Independence:** The structure avoids hierarchical authorization dependencies (`get()`) by denormalizing authorization context where necessary. For example, the `GeneratedAssignment` documents store the `userId` which allows for independent authorization checks without needing to fetch the parent `UserProfile` document.\n*   **Clarity of Intent:** The structure uses clear and consistent naming conventions to make authorization intent explicit. Path-based ownership (`/users/{userId}/...`) clearly indicates ownership, and dedicated collections (`/roles_admin/{uid}`) explicitly define global roles.\n*   **DBAC (No Custom Claims):** Authorization relies solely on `request.auth.uid`. User roles (e.g., admin) are stored in dedicated collections in the database, avoiding the use of custom claims.\n*   **QAPs (Rules are not Filters):** The structure enables secure `list` operations by ensuring that all documents in a collection share the same security requirements. This is achieved through structural segregation, separating data with different access needs into different collections.\n*   **Invariants:** The structure supports the integrity of ownership, timestamps, and denormalized data by enforcing strict naming conventions and using explicit state modeling.\n\nTo specifically support the application's core features:\n\n*   User Authentication: User profiles are stored in `/users/{userId}` with profile data. This enables simple ownership-based security rules.\n*   Premium Subscription System: Subscription data is stored in a subcollection `/users/{userId}/subscriptions/{subscriptionId}`. This allows us to control the tier that user has active at any given time.\n*   Handwriting Analysis: Handwriting models are stored in a subcollection `/users/{userId}/handwritingModels/{handwritingModelId}`. This structure ensures that handwriting models are owned by the respective user and access is controlled by path-based rules.\n*   AI Handwriting Generation: Generated assignments are stored in a subcollection `/users/{userId}/generatedAssignments/{generatedAssignmentId}`. This ensures that generated assignments are owned by the respective user. Each `GeneratedAssignment` also stores the `handwritingModelId` to ensure a handwriting model exists at the time of the assignment generation.\n"
  }
}
